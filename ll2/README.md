# Связанный список (двунаправленный)
#### Определение
Каждый узел списка имеет связь не только со следующим узлом, но и с предыдущим. Таким образом можно передвигаться от начала к концу и от конца к началу по списку.

#### Особенности связного списка:
- некоторые операции становятся эффективнее по сравнению с односвязным списком (операция удаления, например);
- приходится выделять дополнительную "ячейку" памяти под второй указатель.

#### Фиктивный узел:
Существует интересный финт, обсуждаемый на курсе Стэнфордского университета _CS106B_ -- __фиктивный/пустой (dummy) узел__.
В список добавляются два искусственных узла -- голова и хвост, которые пользователю класса не видны.
У каждого узла теперь имеется и предыдущий узел, и последующий в любом случае, и от дополнительных проверок и модификаций полей _head_ и _tail_ __можно избавиться__.

#### Задача 
Реализовать следующий набор функций для работы со списком:
- `find(val)` -- поиск элемента списка имеющего переданное значение. Принимаемое значение: __val__ -- тип не указан, _любой_. Возвращаемое значение: _Node_;
- `find_all(val)` -- поиск всех элементов списка имеющих переданное значение. Принимаемое значение: __val__ -- тип не указан, _любой_. Возвращаемое значение: _список_;
- `delete(val, all=False)`, __all__ -- удалить все найденый элементы, иначе -- только первый найденый элемент. Принимаемые значения: __val__ -- тип не указан, _любой_; __all__ -- _boolean_. Возвращаемое значение: _void_;
- `insert(after_node, new_node)` -- вставка узла после заданнного узла __after_node__. Принимаемые значения: элементы типа __Node__, __after_node__ может быть __None__. Если __after_node__ == __None__, то добавить в конец списка. Возвращаемое значение: _void_.
- `add_in_head(new_node)` -- вставка узла первым элементом. Принимаемое значение: __Node__. Возвращаемое значение: _void_.
- `clean()` -- очистка всего содержимого списка, результат: пустой список. Возвращаемое значение: _void_;
- `len()` -- длина списка. Возвращаемое значение: _кол-во узлов списка_, _int_;
Написать для каждой операции проверочный __тест__.

#### Дополнительно
Реализовать отдельно:
- __двусвязный список с фиктивными узлами__.

#### Дано
- `class Node` -- узел списка, имеет __значение__ (__value__) и указатели __next__ и __prev__ на следующий и предыдущий узлы соответственно;
- `class LinkedList` -- шаблон связного списка с некоторыми предопределенными методами.

Класс _LinkedList_ имеет только два свойства-указателя. На начало и конец списка (__head__ и __tail__). Список хранится __в памяти__ и состоит из отдельных объектов -- __Node__.

#### Комментарии
По сравнению со односвязным списком заметно изменить получилось только операции вставки и удаления, отсальные операции остались такими же или почти такими же.
При вставки узла в данный список по сравнению с односвязным приходится учитывать теперь не только указатель на следующий узел, но и указатель на предыдущий узел. Увеличенной эффективности не обнаружено. Удаление узла же действительно удобнее, так как нет необходимости хранить ссылку на предыдущий узел.

Возможность перебора элементов с конца не реализована и из задачи не совсем понятна зачем нужна, если только список не был бы отсортирован по значению и не имеел бы индексов. Тогда можно было бы оптимизировать операции поиска, удаления и вставки по индексу или значению (использовать бинарный поиск, например).

Список с фиктивными узлами на порядок уменьшает сложность логики операций класса за счет удаления проверок состояния объекта (узлов), связанного с указателями _head_ и _tail_, и все становится проще и "изящнее" в коде.
