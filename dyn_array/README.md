# Динамические массивы

#### Определение

__Динамическим__ называется _массив_, в котором количество элементов, и соответственно выделенный на него объем памяти, может меняться как при инициализации, так и при работе с ним (увеличиваться и уменьшаться).

#### Особенности

- индексируется;
- сложность операции выборки i-го элемента - O(1) благодаря индексированию;
- автоматически расширяется когда в него добавляются новые элементы, и сжимается при удалении элементов.

#### Реаллокация

__Менять реальный размер памяти__, отводимый под массив, каждый раз, когда количество его элементов меняется, __весьма накладно__, так как каждый раз придётся делать __системный вызов__. Поэтому обычно применяется компромиссный вариант: _внутри_ __динамического массива__ существует __буфер__, например на N элементов, и только когда добавляется новый N+1 элемент, размер этого буфера увеличивается с приличным запасом.
__Реаллокации__ массива - изменение _буфера_.

#### Схемы реаллокации

1. __Аддитивная__. Увеличение размер происходит относительно небольшими __фиксированными__ порциями. Применяется, когда размер массива небольшой, и расходы на реаллокацию невелики.
2. __Мультипликативная__. Подразумевает достаточно сильное изменение размера -- в разы, так как реаллокация крупного массива потребует существенных ресурсов. Обычно он удваивается. Политика регулирования размера сильно зависит от конкретной решаемой задачи.
Пример мультипликативной схемы, принятой в стандартной библиотеке Java:

```java
size = (size * 3) / 2 + 1
```

Часто применяется также отношение "золотого сечения" 1,618.

#### Анализ сложности

1. __Агрегированный метод__. Подразумевает вычисление итоговой суммарной оценки всех операций (общее время работы).
2. __Банковский метод__. Идея в том, что дешёвые операции мы делаем чуть дороже, чем они реально стоят, а дорогие наоборот подешевле. При этом удаётся поддерживать всё время положительный баланс, несмотря на то, что дорогие операции по абсолютной цене могут уводить его в минус.
Например, каждый случай вставки элемента, когда реаллокации не происходит, и каждый случай копирования элемента при копировании, можно оценивать не в одну условную операцию записи, а в три. Как только накапливается достаточная сумма, чтобы оплатить очередную реаллокацию, она выполняется. Причём цена её зависит от количества элементов в массиве и выбирается например, как степень двойки, не превышающая новый размер буфера.

В общем случае недостаток _мультипликативной_ схемы реаллокации в том, что размер массива будет увеличиваться __в геометрической прогрессии__, а желаемая сложность __O(1)__ в реальности будет __o(1)__ (в среднем). __Если вставка попадёт на реаллокацию, задержка времени может быть существенной__. Поэтому в противовес _агрегированному_ методу анализа сложности (и, соответственно выбору метода реаллокации) применяют _банковский_ метод.

#### Задача

Реализовать следующий набор функций для работы со списком:

- `insert(i, itm)` -- вставляет в _i_-ю позицию объект _itm_, сдвигая вперёд все последующие элементы. Принимаемые значения: __i__ -- позиция в массиве (индекс), _int_; __itm__ -- тип не указан, _любой_. Возвращаемое значение: _void_. __Новая длина массива может превысить размер буфера__. Если индекс i лежит вне допустимых границ, сгенерировать исключение. Если значение _i_ равно длине рабочего массива _count_, то добавление происходит в конец массива;
- `delete(i)` -- удаляет объект из _i_-й позиции, при необходимости сжимая буфер. Принимаемое значение: __i__ -- позиция в массиве (индекс), _int_. Возвращаемое значение: _void_. Если индекс i лежит вне допустимых границ, сгенерировать исключение.

Оцените меры сложности для этих методов.
Написать тесты, проверяющие работу методов.

#### Дано

- стандартный тип данных Python - `list`. В задаче будет использоваться как динамический массив.
- `class DynArray` -- класс динамического массива, имеет три поля: __count__ -- текущее количество элементов в массиве, __capacity__ -- текущая ёмкость буфера (исходно 16 единиц), и __array__ -- по сути, указатель на блок памяти нужной ёмкости, хранящий элементы __PyObject__.
