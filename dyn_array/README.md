# Динамические массивы

#### Определение

__Динамическим__ называется _массив_, в котором количество элементов, и соответственно выделенный на него объем памяти, может меняться как при инициализации, так и при работе с ним (увеличиваться и уменьшаться).

#### Особенности

- индексируется;
- сложность операции выборки i-го элемента O(1) благодаря индексированию;
- автоматически расширяется когда в него добавляются новые элементы, и сжимается при удалении элементов.

#### Реаллокация

__Менять реальный размер памяти__, отводимый под массив, каждый раз, когда количество его элементов меняется, __весьма накладно__, так как каждый раз придётся делать __системный вызов__. Поэтому обычно применяется компромиссный вариант: _внутри_ __динамического массива__ существует __буфер__, например на N элементов, и только когда добавляется новый N+1 элемент, размер этого буфера увеличивается с приличным запасом.
__Реаллокации__ массива - изменение _буфера_.

#### Схемы реаллокации

1. __Аддитивная__. Увеличение размер происходит относительно небольшими __фиксированными__ порциями. Применяется, когда размер массива небольшой, и расходы на реаллокацию невелики;
2. __Мультипликативная__. Подразумевает достаточно сильное изменение размера -- в разы, так как реаллокация крупного массива потребует существенных ресурсов. Обычно он удваивается. Политика регулирования размера сильно зависит от конкретной решаемой задачи.
Пример мультипликативной схемы, принятой в стандартной библиотеке Java:

```java
size = (size * 3) / 2 + 1
```

Часто применяется также отношение "золотого сечения" 1,618.

#### Анализ сложности

1. __Агрегированный метод__. Подразумевает вычисление итоговой суммарной оценки всех операций (общее время работы).
2. __Банковский метод__. Идея в том, что дешёвые операции мы делаем чуть дороже, чем они реально стоят, а дорогие наоборот подешевле. При этом удаётся поддерживать всё время положительный баланс, несмотря на то, что дорогие операции по абсолютной цене могут уводить его в минус.
Например, каждый случай вставки элемента, когда реаллокации не происходит, и каждый случай копирования элемента при копировании, можно оценивать не в одну условную операцию записи, а в три. Как только накапливается достаточная сумма, чтобы оплатить очередную реаллокацию, она выполняется. Причём цена её зависит от количества элементов в массиве и выбирается например, как степень двойки, не превышающая новый размер буфера.

В общем случае недостаток _мультипликативной_ схемы реаллокации в том, что размер массива будет увеличиваться __в геометрической прогрессии__, а желаемая сложность __O(1)__ в реальности будет __o(1)__ (в среднем). __Если вставка попадёт на реаллокацию, задержка времени может быть существенной__. Поэтому в противовес _агрегированному_ методу анализа сложности (и, соответственно выбору метода реаллокации) применяют _банковский_ метод.

#### ctypes

`ctypes` -- стандартная библиотека _Python_. Множество стандартных функций _Python_ в целях быстродействия написаны на языке _Си_, и `ctypes` предоставляет собой своеобразный интерфейс между _Python_ и _Си_ (и по большому счёту, между _Python_ и операционной системой).
__PyObject__ -- это самый базовый, универсальный класс _Python_, от которого наследуются все остальные его типы.

Обращение `ctypes.py_object` представляет собой так называемый указатель или ссылку, в терминологии Си, на объект __PyObject__. Формально в _Python_ нельзя объявить __PyObject__ как таковой, но вся работа с объектами _Python_ осуществляется через указатели на этот тип, а именно через тип `ctypes.py_object`.

Пример: мы хотим сформировать блок оперативной памяти, где собираемся хранить последовательность значений (объектов). Для этого надо выполнить команду, которая отведёт в памяти N (здесь N = 3) ячеек, предназначенных для хранения объектов (точнее, ссылок на объекты) _Python_.

```python
import ctypes

A = (3 * ctypes.py_object)()
```

Теперь мы можем обращаться к `A` как к адресуемой области памяти! Фактически, _Python_ разрешает нам индексировать эту область напрямую.

```python
A[0] = 1024
A[1] = '1024'
A[2] = 10.24
```

Также `A` поддерживает перечисление, то есть допускается такая запись:

```python
for i in A:
    print(i)
```

Очень важно, что мера сложности такой индексации -- __O(1)__. Система времени выполнения одной операцией определяет местонахождения нужной ссылки на объект в памяти, так как все они имеют одинаковый размер (указатель на _PyObject_).

#### Задача

1. Реализовать следующий набор функций для работы со списком:

- `insert(i, itm)` -- вставляет в _i_-ю позицию объект _itm_, сдвигая вперёд все последующие элементы. Принимаемые значения: __i__ -- позиция в массиве (индекс), _int_; __itm__ -- тип не указан, _любой_. Возвращаемое значение: _void_. __Новая длина массива может превысить размер буфера__. Если индекс i лежит вне допустимых границ, сгенерировать исключение. Если значение _i_ равно длине рабочего массива _count_, то добавление происходит в конец массива;
- `delete(i)` -- удаляет объект из _i_-й позиции, при необходимости сжимая буфер. Принимаемое значение: __i__ -- позиция в массиве (индекс), _int_. Возвращаемое значение: _void_. Если индекс i лежит вне допустимых границ, сгенерировать исключение;

2. Оцените меры сложности для этих методов;
3. Написать тесты, проверяющие работу методов.

_Реализация буфера_

- увеличение буфера происходит в два раза;
- уменьшение в полтора раза (текущее значение размера буфера делится на 1.5, и результат приводится к целому типу, без округлений);
- сохраняется минимальная ёмкость 16 элементов.
- Увеличение буфера выполняется при попытке добавления, когда он весь полностью заполнен.
- Сокращение буфера выполняется после операции удаления, когда его заполненность станет строго меньше, чем заданный процент заполнения (50%).

#### Дано

- стандартный тип данных Python - `list`. В задаче будет использоваться как динамический массив.
- `class DynArray` -- класс динамического массива, имеет три поля: __count__ -- текущее количество элементов в массиве, __capacity__ -- текущая ёмкость буфера (исходно 16 единиц), и __array__ -- по сути, указатель на блок памяти нужной ёмкости, хранящий элементы __PyObject__.
